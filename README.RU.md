BitSet
=====

Это хранилище представляет собой набор инструментов и библиотек Qt для выполнения операций на двоичных данных. Сделано для школьного проекта.

---

Qt библиотеки
-------------

Предоставляет классы для операций по отдельным bitsets, а также оценку BitSet выражений.

`Bitset` инструмент командной строки
------------------------------------

Обеспечивает интерфейс командной строки для разбора BitSet выражений. Ожидает один аргумент - выражение для разбора. Возвращает строковое представление в результате BitSet, если выражение является правильным и синтаксического анализа сообщения об ошибке в противном случае. Работает как следующее:

`Bitset.exe 110 + 101 ^ 110 & 010`

Выражения
-----------------

Expression оценщик поддерживает следующие символы:

* BitSet как это - строка '0' \ `S и` 1` \ `ы
* BitSet чтение из файла - файл `@ <путь_к_файлу> @` будет читать BitSet из файла в `<путь_к_файлу>`. Файл должен существовать, быть доступными, быть текст и не содержат ничего, кроме '0' и '1'. Ошибка генерируется в противном случае.
* `(` И `)` - круглые скобки для изменения порядка вычисления.
* `` Или `` ~ - побитовое отрицание. Оба означают в точности то же самое. `!` Может быть специальный символ в терминале, так что `` ~ является более предпочтительным.
* `&`, `|`, `` ^ - Побитовое И, ИЛИ, исключающее ИЛИ. Заказанный от высокого приоритета с низким приоритетом. И левые, и правые операнды должны быть bitsets.
* `>>` И `` << - правый и левый сдвиг. Левый операнд должен быть BitSet и правильным должно быть числом.
* `+` - Конкатенация. И левый и правый операнд должен быть bitsets.

> * Чем выше оператор находится в списке, тем выше его приоритет.
> * Имейте в виду, что текстовое представление bitsets написаны из наименее значимых битов слева для MSB справа. Так `0100` является` 2`, а не `4`.
> * Если Побитовая операция выполняется на bitsets разной длины, тем короче один заполняется с `0` \` ы в конце, чтобы соответствовать длине более длинный.
> * Все операнды и операторы могут быть разделены одним числом пробельных символов. Тем не менее, никакие пробелы не пускали BitSet, номер, оператор файла (включая путь к файлу), операторы сдвига.

Некоторые примеры правильных выражений и их результаты:

* `101 + 01` является` 10101`.
* `110 + 101 ^ 110 & 010` является` 110111`. `&` Имеет более высокий приоритет, чем `^` и `` ^ выше, чем `+`.
* `10001 | 1011 ^ файл @ operator.txt @ `` operator.txt` представляет собой текстовый файл в рабочем каталоге, который содержит строку `101`. Таким образом, выражение эквивалентно `00001 | 1011 ^ 100` и ​​равна `10001`, так как отсортированный операнд заполняется '0' \` ы на правой стороне.
* `10 + 01 | 1 & 1001`. Пробелы в порядке.

Некоторые неправильные выражения:

* `` 101 &
* `+ 101` - это конкатенация оператор, не унарный плюс. Таким образом, должны иметь оба операнда.
* Файл `@ новой папке / operand.txt @` - не допускаются пробелы в пути к файлу.